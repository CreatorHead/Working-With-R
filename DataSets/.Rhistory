# Assignments
x = 2
# Assignments
x = 1
y <- 3
### Functions
clear
clear()
clean()
### Functions
print("Hello World")
### Calculations
1 + 2
x + 5
y = x + 5
x = sqrt(16)
#Both '=' and '<-' are same
z = "Hello World"
z = 'Hello World'
res = num + str
res = num + str
num = 5
num + str
### Calling Functions
print("Hello World")
class(x)
### Data Types in R
# To find out the data type use the class() function
class(7)
x = 1.3
class(x)
x = 1.3
class(x)
x = 1.3
class(x)
class(state)
state = FALSE
class(state)
# Character
class('a')
# Vector: It's like list, sequence of the same data types. Elements in vector are called as Components
my_vector = c(3,7,11)
my_str_vector = c("Hello", "World", "From", "R")
# If you mix string and numberics, the whole vector becomes string vector
mix_vector = c(3,7,11,"hello")
# If you mix string and numberics, the whole vector becomes string vector
mix_vector = c(3,7,11,"hello")
class(mix_vector)
# Accessing components in a vector
mix_vector[3]
# R matrix (It's line n dimensional array)
my_matrix = matrix(my_vector, nrow = 2, ncol = 2)
# Vector: It's like list, sequence of the same data types. Elements in vector are called as Components
my_vector = c(3,7,11,13)
# R matrix (It's line n dimensional array)
my_matrix = matrix(my_vector, nrow = 2, ncol = 2)
my_matrix
# R matrix (It's line n dimensional array)
my_matrix = matrix(my_vector, nrow = 2, ncol = 2) # It creates a vector of 2x2 and inserts the values from the given vector (my_vector)
1:9
my_matrix2 = matrix(1:9,nrow = 3,ncol = 3)
my_matrix2
my_matrix2
# To Access two dimensional vectors
my_matrix2[2][2]
# To Access two dimensional vectors
my_matrix2[2,2]
# If you provide only the row, it gives the entire row value
my_matrix[3,]
# If you provide only the row, it gives the entire row value
my_matrix2[3,]
# If you provide only the column, it gives the entire column values
my_matrix2[,3]
# Sub-Set of a matrix
my_matrix(1:2,1:2)
# Sub-Set of a matrix
my_matrix2(1:2,1:2)
# Sub-Set of a matrix
my_matrix2[1:2,1:2]
# Or we can substract the rows and columns to get the same output
my_matrix2[-3,-3]
my_data_frame = data.frame(my_vector, my_str_vector)
# Have total population expressed in millions
Countries$Population.2017.Millions = Countries$Total.Population.2017 / 1000000
## Setting up the Working directory
setwd("F:/Workspace/Working With R/DataSets") # TO set a Working Dir
## Importing the dataset
library('readr')
Countries = read_csv("Countries+Population.csv")
summary(Countries)
## Get info about functions
?colnames
?make.names()
colnames(Countries) ## Retrieve or set the row or column names of a matrix-like object.
colnames(Countries) = make.names(colnames(Countries))
## Set columns in the proper format
Countries$Country.Name = as.factor(Countries$Country.Name)
Countries$Country.Code = as.factor(Countries$Country.Code)
## Summary of the data set
summary(Countries)
## Filtering/Subsetting
# Focusing on the first 10 rows
First.Countries.Pop = head(Countries$Total.Population.2017, 10)
First.Countries.Pop
# Create a logical vector
Big.First.Countries.Flag = First.Countries.Pop > 10000000 ## Condition: More than 10 Million
Big.First.Countries.Flag
# Use logical statement to filter data
Big.Countries = Countries[Countries$Total.Population.2017 > 10000000,] # Condition: More than 10 Milliion
Big.Countries
Small.Countries = Countries[Countries$Total.Population.2017 <= 2000000,] # Condition: Less or Equal to 2 Million
Small.Countries
# 2 logical Conditions
# Using AND Operator
Between.6.And.10.Million.Countries = Countries[Countries$Total.Population.2017 > 6000000 &
Countries$Total.Population.2017 < 10000000,]
Between.6.And.10.Million.Countries
# Using OR Operator
Population.Equals.Divisble.By.2.Or.5 = Countries[(Countries$Total.Population.2017 %% 2) == 0 |
(Countries$Total.Population.2017 %% 5) == 0,]
Population.Equals.Divisble.By.2.Or.5
# Binding Columns:
# If 2 datasets, a dataset and a vector, or 2 vectors have the same number of
# values (rows in the case of datasets), they can be placed together into one
# same dataset using cbind()
# This is different from << merging >>, hence there is no row matching system:
# rows need to be in the exact same order for the data to make sense.
# Binging Rows
# If 2 datasets have the same columns (order, data types, names), one can be
# appended under the other using bind()
## rbind()
Big.And.Small.Countries = rbind(Big.Countries,Small.Countries)
Big.And.Small.Countries
Big.Countries.Flag = Big.And.Small.Countries$Total.Population.2017 > 10000000
Big.Countries.Flag
## cbind()
Big.And.Small.Countries = cbind(Big.And.Small.Countries,Big.Countries.Flag)
Big.And.Small.Countries
View(Big.And.Small.Countries)
summary(Big.And.Small.Countries)
## Transforming
# You can create new columns or modify existing ones by applying transformation to them
# Transformation can be adding, substracting, multiplication, dividing, powering etc...
# But it can also be using functions such as log(), exp() etc...
# Have total population expressed in millions
Countries$Population.2017.Millions = Countries$Total.Population.2017 / 1000000
# Have total population expressed in millions
Countries$Population.2017.Millions = Countries$Total.Population.2017 / 1000000
Countries$Population.2017.Millions
# Logarithm
Countries$Random.Pop.Transform = log(Countries$Total.Population.2017)
Countries$Random.Pop.Transform
# Revert back with exponential
Countries$Random.Pop.Transform = exp(Countries$Random.Pop.Transform)
head(Countries$Random.Pop.Transform)
head(Countries$Random.Pop.Transform)
head(Countries$Random.Pop.Transform)
# Sort countries in acending order of population
Countries = Countries[order(Countries$Total.Population.2017),]
Countries
View(Countries)
# Sort in decending order of population
Countries = Countries[order(-Countries$Total.Population.2017),]
View(Countries)
# Import Libraries
library(readr)
library((readxl))
Import first dataset
Countries = read_csv("Countries+Population.csv")
summa
Countries = read_csv("Countries+Population.csv")
summary(Countries)
library(readr)
library((readxl))
## Setting up the Working directory
## Sorting and Merging
# Import Libraries
library(readr)
library((readxl))
## Setting up the Working directory
setwd("F:/Workspace/Working With R/DataSets") # TO set a Working Dir
# Import first dataset
Countries = read_csv("Countries+Population.csv")
summary(Countries)
## Sorting and Merging
# Import Libraries
library(readr)
library((readxl))
## Setting up the Working directory
setwd("F:/Workspace/Working With R/DataSets") # TO set a Working Dir
# Import first dataset
Countries = read_csv("Countries+Population.csv")
summary(Countries)
# Import first dataset
Countries = read_csv("Countries+Population.csv")
summary(Countries)
# Clean column names and set right data types
colnames(Countries) = make.names(colnames(Countries))
colnames(Countries)
Countries$Country.Name = as.factor(Countries$Country.Name)
Countries$Country.Code = as.factor(Countries$Country.Code)
summary(Countries)
# Import second dataset
Countries_Map = read_excel("Countries Region Mapping.xlsx")
# Import second dataset
Countries_Map = readxl::read_excel("Countries Region Mapping.xlsx")
Countries_Map
Countries_Map
View(Countries_Map)
# Set right data types
Countries_Map$Country.Code = as.factor(Countries_Map$Country.Code)
Countries_Map$Region = as.factor(Countries_Map$Region)
Countries_Map$IncomeGroup = as.factor(Countries_Map$IncomeGroup)
library(readr)
library((readxl))
## Setting up the Working directory
setwd("F:/Workspace/Working With R/DataSets") # TO set a Working Dir
# Import first dataset
Countries = read_csv("Countries+Population.csv")
summary(Countries)
# Clean column names and set right data types
colnames(Countries) = make.names(colnames(Countries))
Countries$Country.Name = as.factor(Countries$Country.Name)
Countries$Country.Code = as.factor(Countries$Country.Code)
summary(Countries)
Countries_Map = readxl::read_excel("Countries Region Mapping.xlsx")
View(Countries_Map)
# Set right data types
Countries_Map$Country.Code = as.factor(Countries_Map$Country.Code)
Countries_Map$Region = as.factor(Countries_Map$Region)
Countries_Map$IncomeGroup = as.factor(Countries_Map$IncomeGroup)
# Set right data types
Countries_Map$Country.Code = as.factor(Countries_Map$Country.Code)
Countries_Map$Region = as.factor(Countries_Map$Region)
Countries_Map$IncomeGroup = as.factor(Countries_Map$IncomeGroup)
# Set to ordered factor, and give order
Countries_Map$IncomeGroup = ordered(Countries_Map$IncomeGroup, levels = c("Low income",
"Lower middle income",
"Upper middle income",
"High income"))
class( Countries_Map$IncomeGroup)
summary(Countries_Map)
class( Countries_Map$IncomeGroup)
summary(Countries_Map)
view(Countries_Map)
view(Countries_Map)
View(Countries_Map)
# Set to ordered factor, and give order
Countries_Map$IncomeGroup = ordered(Countries_Map$IncomeGroup, levels = c("Low income",
"Lower middle income",
"Upper middle income",
"High income"))
summary(Countries_Map)
View(Countries_Map)
class(Countries_Map$IncomeGroup)
summary(Countries_Map)
View(Countries_Map)
# Set to ordered factor, and give order
Countries_Map$IncomeGroup = ordered(Countries_Map$IncomeGroup, levels = c("Low income",
"Lower middle income",
"Upper middle income",
"High income"))
summary(Countries_Map)
summary(Countries_Map$IncomeGroup)
## Sorting and Merging
# Import Libraries
library(readr)
library((readxl))
## Setting up the Working directory
setwd("F:/Workspace/Working With R/DataSets") # TO set a Working Dir
# Import first dataset
Countries = read_csv("Countries+Population.csv")
summary(Countries)
# Clean column names and set right data types
colnames(Countries) = make.names(colnames(Countries))
Countries$Country.Name = as.factor(Countries$Country.Name)
Countries$Country.Code = as.factor(Countries$Country.Code)
summary(Countries)
# Import second dataset
Countries_Map = readxl::read_excel("Countries Region Mapping.xlsx")
View(Countries_Map)
# Set right data types
Countries_Map$Country.Code = as.factor(Countries_Map$Country.Code)
Countries_Map$Region = as.factor(Countries_Map$Region)
Countries_Map$IncomeGroup = as.factor(Countries_Map$IncomeGroup)
summary(Countries_Map$IncomeGroup)
summary(Countries_Map$IncomeGroup)
# Set to ordered factor, and give order
Countries_Map$IncomeGroup = ordered(Countries_Map$IncomeGroup, levels = c("Low income",
"Lower middle income",
"Upper middle income",
"High income"))
class(Countries_Map$IncomeGroup)
summary(Countries_Map$IncomeGroup)
View(Countries_Map)
# Import Third Dataset
Countries_Info = read_csv("Countries+Indicators.csv")
colnames(Countries_Info) = make.names(colnames(Countries_Info))
summary(Countries_Info)
summary(Countries_Info)
summary(Countries_Info)
summary(Countries_Info)
# Left Join
temp = merge(Countries, Countries_Map, by= "Country.Code", all.x = TRUE)
# Correct Inner Join
Countries_All = merge(Countries, Countries_Map, by = "Country.Code")
# Full Outer Join
temp2 = merge(Countries_All, Countries_Info, by = "Country.Code", all = True)
# Full Outer Join
temp2 = merge(Countries_All, Countries_Info, by = "Country.Code", all = TRUE)
# Correct Left Join
Countries_All = merge(Countries_All, Countries_Info, by = "Country.Code", all.x = TRUE)
source('F:/Workspace/Working With R/5- Sorting and Merging/1- Sorting and Merging.R', echo=TRUE)
## Remove unwanted object from global environment
rm(temp,temp2)
# Correct Left Join
Countries_All = merge(Countries_All, Countries_Info, by = "Country.Code", all.x = TRUE)
# Full Outer Join
temp2 = merge(Countries_All, Countries_Info, by = "Country.Code", all = TRUE)
# Correct Inner Join
Countries_All = merge(Countries, Countries_Map, by = "Country.Code")
# Left Join
temp = merge(Countries, Countries_Map, by = "Country.Code", all.x = TRUE)
